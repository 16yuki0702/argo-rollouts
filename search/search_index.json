{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Argo Rollouts - Advanced Kubernetes Deployment Controller What is Argo Rollouts? Argo Rollouts introduces a new custom resource called a Rollout to provide additional deployment strategies such as Blue Green and Canary to Kubernetes. The Rollout custom resource provides feature parity with the deployment resource with additional deployment strategies. Check out the Deployment Concepts for more information on the various deployment strategies. Why Argo Rollouts? Deployments resources offer two strategies to deploy changes: RollingUpdate and Recreate . While these strategies can solve a wide number of use cases, large scale production deployments use additional strategies, such as blue-green or canary, that are missing from the Deployment controller. In order to use these strategies in Kubernetes, users are forced to build scripts on top of their deployments. The Argo Rollouts controller provides these strategies as simple declarative, configurable, GitOps-friendly options. Getting Started Quick Start Argo Rollouts can be installed by running the following commands: $ kubectl create namespace argo-rollouts $ kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollout/tree/stable/manifests/install.yaml Check out the getting started guide to walk through creating and then updating a rollout object. How does it work? Similar to the deployment object, the Argo Rollouts controller will manage the creation, scaling, and deletion of ReplicaSets. These ReplicaSets are defined by the spec.template field, which uses the same pod template as the deployment object. When the spec.template is changed, that signals to the Argo Rollouts controller that a new ReplicaSet will be introduced. The controller will use the strategy set within the spec.strategy field in order to determine how the rollout will progress from the old ReplicaSet to the new ReplicaSet. Once that new ReplicaSet has successfully progressed into the stable version, that Rollout will be marked as the stable ReplicaSet. If another change occurs in the spec.template during a transition from a stable ReplicaSet to a new ReplicaSet. The previously new ReplicaSet will be scaled down, and the controller will try to progress the ReplicasSet that reflects the spec.template field. There is more information on the behaviors of each strategy in the spec section. Use cases of Argo Rollouts A user wants to run last minute functional tests on the new version before it starts to serve production traffic. With the BlueGreen strategy, Argo Rollouts allow users to specify a preview service and an active service. The Rollout will configure the preview service to send traffic to the new version while the active service continues to receive production traffic. Once a user is satisfied, they can promote the preview service to be the new active service. ( example ) Before a new version starts receiving live traffic, a generic set of steps need to be executed beforehand. With the BlueGreen Strategy, the user can bring up the new version without it receiving traffic from the active service. Once those steps finish executing, the rollout can cut over traffic to the new version. A user wants to give a small percentage of the production traffic to a new version of their application for a couple of hours. Afterward, they want to scale down the new version and look at some metrics to determine if the new version is performant compared to the old version. Then they will decide if they want to rollout the new version for all of the production traffic or stick with the current version. With the canary strategy, the rollout can scale up a replica with the new version to receive a specified percentage of traffic, wait for a specified amount of time, set the percentage back to 0, and then wait to rollout out to service all of the traffic once the user is satisfied. ( example ) A user wants to slowly give the new version more production traffic. They start by giving it a small percentage of the live traffic and wait a while before giving the new version more traffic. Eventually, the new version will receive all the production traffic. With the canary strategy, the user specifies the percentages they want the new version to receive and the amount of time to wait between percentages. ( example ) A user wants to use the normal Rolling Update strategy from the deployment. If a user uses the canary strategy with no steps, the rollout will use the max surge and max unavailable values to roll to the new version. ( example )","title":"Overview"},{"location":"#argo-rollouts-advanced-kubernetes-deployment-controller","text":"","title":"Argo Rollouts - Advanced Kubernetes Deployment Controller"},{"location":"#what-is-argo-rollouts","text":"Argo Rollouts introduces a new custom resource called a Rollout to provide additional deployment strategies such as Blue Green and Canary to Kubernetes. The Rollout custom resource provides feature parity with the deployment resource with additional deployment strategies. Check out the Deployment Concepts for more information on the various deployment strategies.","title":"What is Argo Rollouts?"},{"location":"#why-argo-rollouts","text":"Deployments resources offer two strategies to deploy changes: RollingUpdate and Recreate . While these strategies can solve a wide number of use cases, large scale production deployments use additional strategies, such as blue-green or canary, that are missing from the Deployment controller. In order to use these strategies in Kubernetes, users are forced to build scripts on top of their deployments. The Argo Rollouts controller provides these strategies as simple declarative, configurable, GitOps-friendly options.","title":"Why Argo Rollouts?"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#quick-start","text":"Argo Rollouts can be installed by running the following commands: $ kubectl create namespace argo-rollouts $ kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollout/tree/stable/manifests/install.yaml Check out the getting started guide to walk through creating and then updating a rollout object.","title":"Quick Start"},{"location":"#how-does-it-work","text":"Similar to the deployment object, the Argo Rollouts controller will manage the creation, scaling, and deletion of ReplicaSets. These ReplicaSets are defined by the spec.template field, which uses the same pod template as the deployment object. When the spec.template is changed, that signals to the Argo Rollouts controller that a new ReplicaSet will be introduced. The controller will use the strategy set within the spec.strategy field in order to determine how the rollout will progress from the old ReplicaSet to the new ReplicaSet. Once that new ReplicaSet has successfully progressed into the stable version, that Rollout will be marked as the stable ReplicaSet. If another change occurs in the spec.template during a transition from a stable ReplicaSet to a new ReplicaSet. The previously new ReplicaSet will be scaled down, and the controller will try to progress the ReplicasSet that reflects the spec.template field. There is more information on the behaviors of each strategy in the spec section.","title":"How does it work?"},{"location":"#use-cases-of-argo-rollouts","text":"A user wants to run last minute functional tests on the new version before it starts to serve production traffic. With the BlueGreen strategy, Argo Rollouts allow users to specify a preview service and an active service. The Rollout will configure the preview service to send traffic to the new version while the active service continues to receive production traffic. Once a user is satisfied, they can promote the preview service to be the new active service. ( example ) Before a new version starts receiving live traffic, a generic set of steps need to be executed beforehand. With the BlueGreen Strategy, the user can bring up the new version without it receiving traffic from the active service. Once those steps finish executing, the rollout can cut over traffic to the new version. A user wants to give a small percentage of the production traffic to a new version of their application for a couple of hours. Afterward, they want to scale down the new version and look at some metrics to determine if the new version is performant compared to the old version. Then they will decide if they want to rollout the new version for all of the production traffic or stick with the current version. With the canary strategy, the rollout can scale up a replica with the new version to receive a specified percentage of traffic, wait for a specified amount of time, set the percentage back to 0, and then wait to rollout out to service all of the traffic once the user is satisfied. ( example ) A user wants to slowly give the new version more production traffic. They start by giving it a small percentage of the live traffic and wait a while before giving the new version more traffic. Eventually, the new version will receive all the production traffic. With the canary strategy, the user specifies the percentages they want the new version to receive and the amount of time to wait between percentages. ( example ) A user wants to use the normal Rolling Update strategy from the deployment. If a user uses the canary strategy with no steps, the rollout will use the max surge and max unavailable values to roll to the new version. ( example )","title":"Use cases of Argo Rollouts"},{"location":"deployment-concepts/","text":"Deployment Concepts While the industry has agreed upon high-level definitions of various deployment strategies, the implementations of these strategies tend to differ across tooling. To make it clear how the Argo Rollouts will behave, here are the descriptions of the various deployment strategies implementations offered by the Argo Rollouts. Rolling Update A RollingUpdate slowly replaces the old version with the new version. As the new version comes up, the old version is scaled down in order to maintain the overall count of the application. This is the default strategy of the deployment object. Recreate A Recreate deployment deletes the old version of the application before bring up the new version. As a result, this ensures that two versions of the application never run at the same time, but there is downtime during the deployment. Blue Green A Blue Green deployment (which is sometimes referred to as a Red-Black) has both the new and old version of the application deployed at the same time. During this time, only the old version of the application will receive production traffic. This allows the developers to run tests against the new version before switching the live traffic to the new version. Canary A Canary deployment exposes a subset of users (usually 5%) to the new version of the application while serving the rest of the traffic to the old version. Once the new version is verified to be correct that the new version can gradually replace the old version. Service Meshes like Istio make canary deployments easily to rollout as the service mesh can filter the traffic for you.","title":"Concepts"},{"location":"deployment-concepts/#deployment-concepts","text":"While the industry has agreed upon high-level definitions of various deployment strategies, the implementations of these strategies tend to differ across tooling. To make it clear how the Argo Rollouts will behave, here are the descriptions of the various deployment strategies implementations offered by the Argo Rollouts.","title":"Deployment Concepts"},{"location":"deployment-concepts/#rolling-update","text":"A RollingUpdate slowly replaces the old version with the new version. As the new version comes up, the old version is scaled down in order to maintain the overall count of the application. This is the default strategy of the deployment object.","title":"Rolling Update"},{"location":"deployment-concepts/#recreate","text":"A Recreate deployment deletes the old version of the application before bring up the new version. As a result, this ensures that two versions of the application never run at the same time, but there is downtime during the deployment.","title":"Recreate"},{"location":"deployment-concepts/#blue-green","text":"A Blue Green deployment (which is sometimes referred to as a Red-Black) has both the new and old version of the application deployed at the same time. During this time, only the old version of the application will receive production traffic. This allows the developers to run tests against the new version before switching the live traffic to the new version.","title":"Blue Green"},{"location":"deployment-concepts/#canary","text":"A Canary deployment exposes a subset of users (usually 5%) to the new version of the application while serving the rest of the traffic to the old version. Once the new version is verified to be correct that the new version can gradually replace the old version. Service Meshes like Istio make canary deployments easily to rollout as the service mesh can filter the traffic for you.","title":"Canary"},{"location":"getting-started/","text":"Getting Started Requirements Installed kubectl command-line tool Have a kubeconfig file (default location is ~/.kube/config). Install Argo Rollouts Argo Rollouts can be installed at a cluster or namespace level. Cluster-Level installation kubectl create namespace argo-rollouts kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml This will create a new namespace, argo-rollouts , where Argo Rollouts controller will live. On GKE, you will need grant your account the ability to create new cluster roles: kubectl create clusterrolebinding YOURNAME-cluster-admin-binding --clusterrole = cluster-admin --user = YOUREMAIL@gmail.com Namespace-Level Installation kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/namespace-install.yaml Converting Deployment to Rollout Converting a Deployment to a Rollout simply is a core design principle of Argo Rollouts. There are two key changes: Changing the apiVersion value to argoproj.io/v1alpha1 and changing the kind value from Deployment to Rollout Adding a new deployment strategy to the new Rollout. You can read up on the available strategies at [Argo Rollouts section](spec/index.md Below is an example of a Rollout YAML using the Canary strategy. apiVersion : argoproj.io/v1alpha1 # Changed from apps/v1 kind : Rollout # Changed from Deployment # ----- Everything below this comment is the same as a deployment ----- metadata : name : example-rollout spec : replicas : 5 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : # ----- Everything above this comment are the same as a deployment ----- canary : # A new field that used to provide configurable options for a Canary strategy steps : - setWeight : 20 - pause : {} Updating the Rollout The initial creation of the above Rollout will bring up all 5 replicas of the Pod Spec listed. Since the rollout was not in a stable state beforehand (as it was just created), the rollout will skip the steps listed in the .spec.strategy.canary.steps field to first become stable. Once the new ReplicaSet is healthy, updating any field in the spec.template will cause the rollout to create a new ReplicaSet and execute the steps in spec.strategy.canary.steps to transition to the new version. To demonastrate this, we will update the rollout to use a new nginx image. You can either run kubectl edit rollout example-rollout and change the image from nginx:1.15.4 to nginx:1.15.5 , or run the following: $ kubectl patch rollout example-rollout -p { spec : { template : { spec : { containers : [{ name : ngnix , image : nginx:1.15.5 }]}}}} Once the patch is applied, you can watch the new replicaset came up as healthy by running $ kubectl get replicaset -w -o wide Once that replicaset is healthy, the rollout will enter a paused state by setting the spec.paused field to true, and setting the .status.pauseStartedTime to the current time. Unpausing the rollout The rollout can be unpaused by running kubectl edit rollout example-rollout and setting the spec.paused field to false or the following $ kubectl patch rollout example-rollout -p { spec : { paused : false}} At this point, the Rollout has executed all the steps to transition to a new version. As a result, the new ReplicaSet is considered the new stable ReplicaSet, and the previous ReplicaSet will be scaled down. The Rollout will repeat this behavior if the Pod Spec Template is changed again. Going forward Check out the spec documentation for more information on other available configuration for a rollout.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#requirements","text":"Installed kubectl command-line tool Have a kubeconfig file (default location is ~/.kube/config).","title":"Requirements"},{"location":"getting-started/#install-argo-rollouts","text":"Argo Rollouts can be installed at a cluster or namespace level.","title":"Install Argo Rollouts"},{"location":"getting-started/#cluster-level-installation","text":"kubectl create namespace argo-rollouts kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml This will create a new namespace, argo-rollouts , where Argo Rollouts controller will live. On GKE, you will need grant your account the ability to create new cluster roles: kubectl create clusterrolebinding YOURNAME-cluster-admin-binding --clusterrole = cluster-admin --user = YOUREMAIL@gmail.com","title":"Cluster-Level installation"},{"location":"getting-started/#namespace-level-installation","text":"kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/namespace-install.yaml","title":"Namespace-Level Installation"},{"location":"getting-started/#converting-deployment-to-rollout","text":"Converting a Deployment to a Rollout simply is a core design principle of Argo Rollouts. There are two key changes: Changing the apiVersion value to argoproj.io/v1alpha1 and changing the kind value from Deployment to Rollout Adding a new deployment strategy to the new Rollout. You can read up on the available strategies at [Argo Rollouts section](spec/index.md Below is an example of a Rollout YAML using the Canary strategy. apiVersion : argoproj.io/v1alpha1 # Changed from apps/v1 kind : Rollout # Changed from Deployment # ----- Everything below this comment is the same as a deployment ----- metadata : name : example-rollout spec : replicas : 5 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : # ----- Everything above this comment are the same as a deployment ----- canary : # A new field that used to provide configurable options for a Canary strategy steps : - setWeight : 20 - pause : {}","title":"Converting Deployment to Rollout"},{"location":"getting-started/#updating-the-rollout","text":"The initial creation of the above Rollout will bring up all 5 replicas of the Pod Spec listed. Since the rollout was not in a stable state beforehand (as it was just created), the rollout will skip the steps listed in the .spec.strategy.canary.steps field to first become stable. Once the new ReplicaSet is healthy, updating any field in the spec.template will cause the rollout to create a new ReplicaSet and execute the steps in spec.strategy.canary.steps to transition to the new version. To demonastrate this, we will update the rollout to use a new nginx image. You can either run kubectl edit rollout example-rollout and change the image from nginx:1.15.4 to nginx:1.15.5 , or run the following: $ kubectl patch rollout example-rollout -p { spec : { template : { spec : { containers : [{ name : ngnix , image : nginx:1.15.5 }]}}}} Once the patch is applied, you can watch the new replicaset came up as healthy by running $ kubectl get replicaset -w -o wide Once that replicaset is healthy, the rollout will enter a paused state by setting the spec.paused field to true, and setting the .status.pauseStartedTime to the current time.","title":"Updating the Rollout"},{"location":"getting-started/#unpausing-the-rollout","text":"The rollout can be unpaused by running kubectl edit rollout example-rollout and setting the spec.paused field to false or the following $ kubectl patch rollout example-rollout -p { spec : { paused : false}} At this point, the Rollout has executed all the steps to transition to a new version. As a result, the new ReplicaSet is considered the new stable ReplicaSet, and the previous ReplicaSet will be scaled down. The Rollout will repeat this behavior if the Pod Spec Template is changed again.","title":"Unpausing the rollout"},{"location":"getting-started/#going-forward","text":"Check out the spec documentation for more information on other available configuration for a rollout.","title":"Going forward"},{"location":"features/","text":"Overview This section has all the features of Argo Rollouts. Check out rollout.yaml for a fully annotated Rollout.","title":"Overview"},{"location":"features/#overview","text":"This section has all the features of Argo Rollouts. Check out rollout.yaml for a fully annotated Rollout.","title":"Overview"},{"location":"features/bluegreen/","text":"BlueGreen Deployment Strategy A Blue Green Deployment allows users to reduce the amount of time multiple versions running at the same time. Overview In addition to managing ReplicaSets, the rollout controller will modify a Service resource during the BlueGreenUpdate strategy. The Rollout spec has users specify a reference to active service and optionally a preview service in the same namespace. The active Service is used to send regular application traffic to the old version, while the preview Service is used as funnel traffic to the new version. The rollout controller ensures proper traffic routing by injecting a unique hash of the ReplicaSet to these services' selectors. This allows the rollout to define an active and preview stack and a process to migrate replica sets from the preview to the active. When there is a change to the .spec.template field of a rollout, the controller will create the new ReplicaSet. If the active service is not sending traffic to a ReplicaSet, the controller will immediately start sending traffic to the ReplicaSet. Otherwise, the active service will point at the old ReplicaSet while the ReplicaSet becomes available. Once the new ReplicaSet becomes available, the controller will modify the active service to point at the new ReplicaSet. After waiting some time configured by the .spec.strategy.blueGreen.scaleDownDelaySeconds , the controller will scale down the old ReplicaSet. Important note When the rollout changes the selector on a service, there is a propagation delay before all the nodes update their IP tables to send traffic to the new pods instead of the old. During this delay, traffic will be directed to the old pods if the nodes have not been updated yet. In order to prevent the packets from being sent to a node that killed the old pod, the rollout uses the scaleDownDelaySeconds field to give nodes enough time to broadcast the IP table changes. Configurable Features Here are the optional fields that will change the behavior of BlueGreen deployment: spec : strategy : blueGreen : previewService : string previewReplicaCount : *int32 autoPromotionSeconds : *int32 scaleDownDelaySeconds : *int32 PreviewService The PreviewService field references a Service that will be modified to send traffic to the new replicaset before the new one is promoted to receiving traffic from the active service. Once the new replicaset start receives traffic from the active service, the preview service will be modified to send traffic to no ReplicaSets. The Rollout always makes sure that the preview service is sending traffic to the new ReplicaSet. As a result, if a new version is introduced before the old version is promoted to the active service, the controller will immediately switch over to the new version. This feature is used to provide an endpoint that can be used to test a new version of an application. Defaults to an empty string PreviewReplicaCount The PreviewReplicaCount will indicate the number of replicas that the new version of an application should run. Once the application is ready to promote to the active service, the controller will scale the new ReplicaSet to the value of the spec.replicas . The rollout will not switch over the active service to the new ReplicaSet until it matches the spec.replicas count. This feature is mainly used to save resources during the testing phase. If the application does not need a fully scaled up application for the tests, this feature can help save some resources. Defaults to nil AutoPromotionEnabled The AutoPromotionEnabled will make the rollout automatically promote the new ReplicaSet to the active service once the new ReplicaSet is healthy. This field is defaulted to true if it is not specified. Defaults to true AutoPromotionSeconds The AutoPromotionSeconds will make the rollout automatically promote the new ReplicaSet to active Service after the AutoPromotionSeconds time has passed since the rollout has entered a paused state. If the AutoPromotionEnabled field is set to true, this field will be ignored Defaults to nil ScaleDownDelaySeconds The ScaleDownDelaySeconds is used to delay scaling down the old ReplicaSet after the active Service is switched to the new ReplicaSet. Defaults to 30","title":"BlueGreen"},{"location":"features/bluegreen/#bluegreen-deployment-strategy","text":"A Blue Green Deployment allows users to reduce the amount of time multiple versions running at the same time.","title":"BlueGreen Deployment Strategy"},{"location":"features/bluegreen/#overview","text":"In addition to managing ReplicaSets, the rollout controller will modify a Service resource during the BlueGreenUpdate strategy. The Rollout spec has users specify a reference to active service and optionally a preview service in the same namespace. The active Service is used to send regular application traffic to the old version, while the preview Service is used as funnel traffic to the new version. The rollout controller ensures proper traffic routing by injecting a unique hash of the ReplicaSet to these services' selectors. This allows the rollout to define an active and preview stack and a process to migrate replica sets from the preview to the active. When there is a change to the .spec.template field of a rollout, the controller will create the new ReplicaSet. If the active service is not sending traffic to a ReplicaSet, the controller will immediately start sending traffic to the ReplicaSet. Otherwise, the active service will point at the old ReplicaSet while the ReplicaSet becomes available. Once the new ReplicaSet becomes available, the controller will modify the active service to point at the new ReplicaSet. After waiting some time configured by the .spec.strategy.blueGreen.scaleDownDelaySeconds , the controller will scale down the old ReplicaSet. Important note When the rollout changes the selector on a service, there is a propagation delay before all the nodes update their IP tables to send traffic to the new pods instead of the old. During this delay, traffic will be directed to the old pods if the nodes have not been updated yet. In order to prevent the packets from being sent to a node that killed the old pod, the rollout uses the scaleDownDelaySeconds field to give nodes enough time to broadcast the IP table changes.","title":"Overview"},{"location":"features/bluegreen/#configurable-features","text":"Here are the optional fields that will change the behavior of BlueGreen deployment: spec : strategy : blueGreen : previewService : string previewReplicaCount : *int32 autoPromotionSeconds : *int32 scaleDownDelaySeconds : *int32","title":"Configurable Features"},{"location":"features/bluegreen/#previewservice","text":"The PreviewService field references a Service that will be modified to send traffic to the new replicaset before the new one is promoted to receiving traffic from the active service. Once the new replicaset start receives traffic from the active service, the preview service will be modified to send traffic to no ReplicaSets. The Rollout always makes sure that the preview service is sending traffic to the new ReplicaSet. As a result, if a new version is introduced before the old version is promoted to the active service, the controller will immediately switch over to the new version. This feature is used to provide an endpoint that can be used to test a new version of an application. Defaults to an empty string","title":"PreviewService"},{"location":"features/bluegreen/#previewreplicacount","text":"The PreviewReplicaCount will indicate the number of replicas that the new version of an application should run. Once the application is ready to promote to the active service, the controller will scale the new ReplicaSet to the value of the spec.replicas . The rollout will not switch over the active service to the new ReplicaSet until it matches the spec.replicas count. This feature is mainly used to save resources during the testing phase. If the application does not need a fully scaled up application for the tests, this feature can help save some resources. Defaults to nil","title":"PreviewReplicaCount"},{"location":"features/bluegreen/#autopromotionenabled","text":"The AutoPromotionEnabled will make the rollout automatically promote the new ReplicaSet to the active service once the new ReplicaSet is healthy. This field is defaulted to true if it is not specified. Defaults to true","title":"AutoPromotionEnabled"},{"location":"features/bluegreen/#autopromotionseconds","text":"The AutoPromotionSeconds will make the rollout automatically promote the new ReplicaSet to active Service after the AutoPromotionSeconds time has passed since the rollout has entered a paused state. If the AutoPromotionEnabled field is set to true, this field will be ignored Defaults to nil","title":"AutoPromotionSeconds"},{"location":"features/bluegreen/#scaledowndelayseconds","text":"The ScaleDownDelaySeconds is used to delay scaling down the old ReplicaSet after the active Service is switched to the new ReplicaSet. Defaults to 30","title":"ScaleDownDelaySeconds"},{"location":"features/canary/","text":"Canary Deployment Strategy A canary rollout is a deployment strategy where the operator releases a new version of their application to a small percentage of the production traffic. Overview Since there is no agreed upon standard for a canary deployment, the rollouts controller allows users to outline how they want to run their canary deployment. Users can define a list of steps the controller uses to manipulate the RepliaSets where there is a change to the .spec.template . Each step will be evaluated before the new ReplicaSet is promoted to the stable version, and the old version is completely scaled down. Each step can have one of two fields. The setWeight field dictates the percentage of traffic that should be sent to the canary, and the pause struct instructs the rollout to pause. When the controller reaches a pause step for a rollout, it will set the .spec.paused field to true . If the duration field within the pause struct is set, the rollout will not progress to the next step until it has waited for the value of the duration field. Otherwise, the rollout will wait indefinitely until the .spec.paused field is set to false . By using the setWeight and the pause fields, a user can declarative describe how they want to progress to the new version. Below is an example of a canary strategy. Example apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout spec : replicas : 10 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : canary : #Indicates that the rollout should use the Canary strategy maxSurge : 25% maxUnavailable : 0, steps : - setWeight : 10 - pause : duration : 3600 # 1 hour - setWeight : 20 - pause : {} Mimicking Rolling Update If the steps field is omitted, the canary strategy will mimic the rolling update behavior. Similar to the deployment, the canary strategy has the maxSurge and maxUnavailable fields to configure how the Rollout should progress to the new version. Other Configurable Features Here are the optional fields that will modify the behavior of canary strategy: spec : strategy : canary : maxSurge : stringOrInt maxUnavailable : stringOrInt canaryService : string maxSurge maxSurge defines the maximum number of replicas the rollout can create to move to the correct ratio set by the last setWeight. Max Surge can either be an integer or percentage as a string (i.e. \"20%\") Defaults to \"25%\". maxUnavailable The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0. // Defaults to 0 CanaryService canaryService references a Service that will be modified to send traffic to only the canary ReplicaSet. This allows users to only hit the canary ReplicaSet. Defaults to an empty string","title":"Canary"},{"location":"features/canary/#canary-deployment-strategy","text":"A canary rollout is a deployment strategy where the operator releases a new version of their application to a small percentage of the production traffic.","title":"Canary Deployment Strategy"},{"location":"features/canary/#overview","text":"Since there is no agreed upon standard for a canary deployment, the rollouts controller allows users to outline how they want to run their canary deployment. Users can define a list of steps the controller uses to manipulate the RepliaSets where there is a change to the .spec.template . Each step will be evaluated before the new ReplicaSet is promoted to the stable version, and the old version is completely scaled down. Each step can have one of two fields. The setWeight field dictates the percentage of traffic that should be sent to the canary, and the pause struct instructs the rollout to pause. When the controller reaches a pause step for a rollout, it will set the .spec.paused field to true . If the duration field within the pause struct is set, the rollout will not progress to the next step until it has waited for the value of the duration field. Otherwise, the rollout will wait indefinitely until the .spec.paused field is set to false . By using the setWeight and the pause fields, a user can declarative describe how they want to progress to the new version. Below is an example of a canary strategy.","title":"Overview"},{"location":"features/canary/#example","text":"apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout spec : replicas : 10 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : canary : #Indicates that the rollout should use the Canary strategy maxSurge : 25% maxUnavailable : 0, steps : - setWeight : 10 - pause : duration : 3600 # 1 hour - setWeight : 20 - pause : {}","title":"Example"},{"location":"features/canary/#mimicking-rolling-update","text":"If the steps field is omitted, the canary strategy will mimic the rolling update behavior. Similar to the deployment, the canary strategy has the maxSurge and maxUnavailable fields to configure how the Rollout should progress to the new version.","title":"Mimicking Rolling Update"},{"location":"features/canary/#other-configurable-features","text":"Here are the optional fields that will modify the behavior of canary strategy: spec : strategy : canary : maxSurge : stringOrInt maxUnavailable : stringOrInt canaryService : string","title":"Other Configurable Features"},{"location":"features/canary/#maxsurge","text":"maxSurge defines the maximum number of replicas the rollout can create to move to the correct ratio set by the last setWeight. Max Surge can either be an integer or percentage as a string (i.e. \"20%\") Defaults to \"25%\".","title":"maxSurge"},{"location":"features/canary/#maxunavailable","text":"The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0. // Defaults to 0","title":"maxUnavailable"},{"location":"features/canary/#canaryservice","text":"canaryService references a Service that will be modified to send traffic to only the canary ReplicaSet. This allows users to only hit the canary ReplicaSet. Defaults to an empty string","title":"CanaryService"},{"location":"features/controller-metrics/","text":"","title":"Controller Metrics"},{"location":"features/hpa-support/","text":"Horizontal Pod Autoscaling Horizontal Pod Autoscaling (HPA) automatically scales the number of pods in owned by a Kubernetes resource based on observed CPU utilization or user-configured metrics. In order to accomplish this behavior, HPA only supports resources with the scale endpoint enabled with a couple of required fields. The scale endpoint allows the HPA to understand the current state of a resource and modify the resource to scale it appropriately. Argo Rollouts added support for the scale endpoint in the 0.3.0 release. After being modified by the HPA, the Argo Rollouts controller is responsible for reconciling that change in replicas. Since the strategies within a Rollout are very different, the Argo Rollouts controller handles the scale endpoint differently for various strategies. Below is the behavior for the different strategies: Blue Green The HPA will scale rollouts using the BlueGreen strategy using the metrics from the ReplicaSet receiving traffic from the active service. When the HPA changes the replicas count, the Argo Rollouts controller will first scale up the ReplicaSet receiving traffic from the active service before ReplicaSet receiving traffic from the preview service. The controller will scale up the ReplicaSet receiving traffic from the preview service to prepare it for when the rollout switches the preview to active. If there are no ReplicaSets receiving from the active service, the controller will use all the pods that match the base selector to determine scaling events. In that case, the controller will scale up the latest ReplicaSet to the new count and scale down the older ReplicaSets. Canary (ReplicaSet based) The HPA will scale rollouts using the Canary Strategy using the metrics of all the ReplicasSets within the rollout. Since the Argo Rollouts controller does not control the service that sends traffic to those ReplicaSets, it assumes that all the ReplicaSets in the rollout are receiving traffic. Example Below is an example of a Horizontal Pod Autoscaler that scales a rollout based on CPU metrics: apiVersion : autoscaling/v1 kind : HorizontalPodAutoscaler metadata : name : hpa-rollout-example spec : maxReplicas : 6 minReplicas : 2 scaleTargetRef : apiVersion : argoproj.io kind : Rollout name : example-rollout targetCPUUtilizationPercentage : 80 Requirements In order for the HPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs. This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11. If a user wants to use HPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server. After 1.10, the flag is turned on by default. Check out the following link for more information on setting the custom feature flag.","title":"HPA Support"},{"location":"features/hpa-support/#horizontal-pod-autoscaling","text":"Horizontal Pod Autoscaling (HPA) automatically scales the number of pods in owned by a Kubernetes resource based on observed CPU utilization or user-configured metrics. In order to accomplish this behavior, HPA only supports resources with the scale endpoint enabled with a couple of required fields. The scale endpoint allows the HPA to understand the current state of a resource and modify the resource to scale it appropriately. Argo Rollouts added support for the scale endpoint in the 0.3.0 release. After being modified by the HPA, the Argo Rollouts controller is responsible for reconciling that change in replicas. Since the strategies within a Rollout are very different, the Argo Rollouts controller handles the scale endpoint differently for various strategies. Below is the behavior for the different strategies:","title":"Horizontal Pod Autoscaling"},{"location":"features/hpa-support/#blue-green","text":"The HPA will scale rollouts using the BlueGreen strategy using the metrics from the ReplicaSet receiving traffic from the active service. When the HPA changes the replicas count, the Argo Rollouts controller will first scale up the ReplicaSet receiving traffic from the active service before ReplicaSet receiving traffic from the preview service. The controller will scale up the ReplicaSet receiving traffic from the preview service to prepare it for when the rollout switches the preview to active. If there are no ReplicaSets receiving from the active service, the controller will use all the pods that match the base selector to determine scaling events. In that case, the controller will scale up the latest ReplicaSet to the new count and scale down the older ReplicaSets.","title":"Blue Green"},{"location":"features/hpa-support/#canary-replicaset-based","text":"The HPA will scale rollouts using the Canary Strategy using the metrics of all the ReplicasSets within the rollout. Since the Argo Rollouts controller does not control the service that sends traffic to those ReplicaSets, it assumes that all the ReplicaSets in the rollout are receiving traffic.","title":"Canary (ReplicaSet based)"},{"location":"features/hpa-support/#example","text":"Below is an example of a Horizontal Pod Autoscaler that scales a rollout based on CPU metrics: apiVersion : autoscaling/v1 kind : HorizontalPodAutoscaler metadata : name : hpa-rollout-example spec : maxReplicas : 6 minReplicas : 2 scaleTargetRef : apiVersion : argoproj.io kind : Rollout name : example-rollout targetCPUUtilizationPercentage : 80","title":"Example"},{"location":"features/hpa-support/#requirements","text":"In order for the HPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs. This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11. If a user wants to use HPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server. After 1.10, the flag is turned on by default. Check out the following link for more information on setting the custom feature flag.","title":"Requirements"},{"location":"features/kustomize/","text":"Kustomize Integration Kustomize can be extended to understand CRD objects through the use of transformer configs . Using transformer configs, kustomize can be \"taught\" about the structure of a Rollout object and leverage kustomize features such as ConfigMap/Secret generators, variable references, and common labels annotations. To use Rollouts with kustomize: Download rollout-transform.yaml into your kustomize directory. Include rollout-transform.yaml in your kustomize configurations section: kind : Kustomization apiVersion : kustomize.config.k8s.io/v1beta1 configurations : - rollout-transform.yaml A example kustomize app demonstrating the ability to use transformers with Rollouts can be seen here .","title":"Kustomize Support"},{"location":"features/kustomize/#kustomize-integration","text":"Kustomize can be extended to understand CRD objects through the use of transformer configs . Using transformer configs, kustomize can be \"taught\" about the structure of a Rollout object and leverage kustomize features such as ConfigMap/Secret generators, variable references, and common labels annotations. To use Rollouts with kustomize: Download rollout-transform.yaml into your kustomize directory. Include rollout-transform.yaml in your kustomize configurations section: kind : Kustomization apiVersion : kustomize.config.k8s.io/v1beta1 configurations : - rollout-transform.yaml A example kustomize app demonstrating the ability to use transformers with Rollouts can be seen here .","title":"Kustomize Integration"}]}